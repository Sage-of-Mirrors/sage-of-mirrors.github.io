<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Dylan Ascencio | Home</title>
    <link rel="stylesheet" href="css/bulma.min.css">
	<link rel="stylesheet" href="css/bulma-carousel.min.css">
	<style>
		html, body, .section, { height: 100%; }
		.navbar-start {
			flex-grow: 1;
			justify-content: center;
		}
		.carousel {
			overflow: hidden;
		}
	</style>
  </head>
  <body>
    <nav class="navbar is-spaced is-dark has-shadow" role="navigation" aria-label="main navigation" style="background-color: #443144;">
      <div class="container">
        <div id="navbarBasicExample" class="navbar-menu">
          <div class="navbar-start">
            <a class="navbar-item" href="index.html">Home</a>
			<a class="navbar-item" href="resume.html">Resume</a>
			<a class="navbar-item" href="contact.html">Contact</a>
          </div>
        </div>
      </div>
    </nav>
	<section class="section has-background-dark has-carousel">
	 <div class="columns is-mobile">
		<div class="column is-half is-offset-one-quarter">
			<div class="box has-text-grey-lighter has-background-grey-dark">
				<h3 class="title has-text-grey-lighter">About Me</h3>
				<p>
					My name is Dylan Ascencio. Software engineer and game developer. I graduated from the University of Wisconsin-Stout, majoring in Computer Science with a concentration in Game Design, in May of 2020; I am currently a programming contractor with Gears for Breakfast.
				</p><br>
				<p>
					Feel free to read about my projects here, look at my <a href="resume.html">resume</a>, or find out how to <a href="contact.html">contact me</a>.
				</p><br>
				<h1 class="title has-text-white-ter"><u>My Work</u></h1>
				
				<!-- Nyakuza Metro -->
				<h3 class="title has-text-grey-lighter">A Hat in Time: Nyakuza Metro</h3>
				<p>
					In 2019, I was brought on as a programming contractor with Gears for Breakfast to help ship the second DLC pack for <em>A Hat in Time</em>, Nyakuza Metro. During my time with them, I helped
					to fix bugs in existing gameplay objects and prototyped behaviors for new ones in UnrealScript. I also worked with Unreal Engine 3's Kismet editor to adjust the flow of certain events
					within the level, and with the Matin√©e editor to prototype new features for sequences.
				</p><br>
				
				<!-- Thomson Reuters -->
				<h3 class="title has-text-grey-lighter">Thomson Reuters (via Maverick Software Consulting)</h3>
				<p>
					From June to December of 2018, I did an internship at Thomson Reuters' Eagan, Minnesota campus through Maverick Software Consulting. After a two-week onboarding period, I was fully integrated
					into one of Thomson Reuters' cloud services development teams. As part of that team I worked with JSON, YAML, and Python to create tools to make deployment of Amazon Web Services resources
					for other teams easier and more efficient. There was a heavy emphasis on unit and regression testing, using <a href="https://docs.python.org/3/library/unittest.mock.html">mocking</a>
					and <a href="https://en.wikipedia.org/wiki/Tox_(Python_testing_wrapper)">tox</a> to ensure that these tests covered as much of the code as possible. We used JIRA to keep track of our
					assigned issues and testing plans.
				</p><br>
				
				<h1 class="title has-text-white-ter"><u>My Academic Projects</u></h1>
				
				<h3 class="title has-text-grey-lighter">Nekiri's Tail</h3>
				<p>
				   Nekiri's Tail is the capstone project of my education at UW-Stout. It is a stealth-based puzzle game built in Unreal Engine 4. The player controls a cat spirit that endeavors to protect the city's inhabitants
				   from the evil spirits of the Damned, who have risen from the underworld to take over their bodies. The game was created in collaboration with a team of ten - six programmers and four artists. We were all either in the
				   Game Design program or had a concentration in Game Design.
				</p><br>
				   
				<p>
				   The game's main mechanic is the ability of the cat to possess the townsfolk itself. As the cat, the player can reach high places by jumping, allowing them to retrieve out-of-reach objects or reach otherwise inaccessible
				   locations. Controlling the cat is meant to give the player a feeling of being nimble, and in this form they can outrun the Damned. However, this is contrasted by the human form that the player can switch to.
				   While the human form can use its higher strength and thumbs to do "human" things like pull levers and open doors, it is much slower than the cat, and cannot outrun the Damned. The cat must be in physical proximity to the
				   human in order to transfer control - it cannot be done at a distance. The human can also only be moved while the cat is possessing it. Thus, in order to progress, any Damned that are blocking the human's path through the
				   level must be dealt with. This includes distracting them with sound or knocking a vase onto their heads, which temporarly incapacitates them.
				</p><br>
				   
				<p>
					<b>My Contributions</b>
				</p><br>
				   
				<p>
				   I was the architect of the Damned's AI.
				</p><br>
				
				<h1 class="title has-text-white-ter"><u>My Personal Projects</u></h1>
				
				<!-- Winditor -->
				<h3 class="title has-text-grey-lighter">Winditor</h3>
				<p><b>GitHub Repository:</b> <a href="https://github.com/Sage-of-Mirrors/Winditor">https://github.com/Sage-of-Mirrors/Winditor</a></p><br>
				<p>
					Winditor is a multi-purpose editor for the 2003 GameCube game <em>The Legend of Zelda: The Wind Waker</em>. The suite includes editors for maps, collision, text, drop items, and more.
					The project has been an ongoing effort by multiple people for several years, and the current iteration was led by Matt "LordNed" Hoffman and I. I have heavily contributed to this
					open-source project, and I am responsible for large parts of its UI and functionality.
				</p><br>
				
				<h5 class="title has-text-grey-lighter">Map Editor</h5>
				<div class="card-image has-text-centered">
					<figure class="image is-256x256 is-inline-block"><img src="img/winditor_actor.png" alt="a"/></figure>
				</div>
				<p>
					The map editor is Winditor's default mode, and it allows the user to create and edit levels. As shown above, once the user selects a directory containing a level, they are presented
					with a 3D view of the level in the center of the screen flanked by two panels. The panel on the left shows the components of the level (scenes) and the objects that are spawned within the level, while the panel on the right is reserved for a details panel that displays the editable properties of a selected object. Objects can be selected by either clicking on them in the 3D view
					or clicking them in the hierarchy shown in the left panel.
				</p><br>
				
				<h5 class="title has-text-grey-lighter">Collision Editor</h5>
				<div class="card-image has-text-centered">
					<figure class="image is-256x256 is-inline-block"><img src="img/winditor_collision.png" alt="a"/></figure>
				</div>
				<p>
					The collision editor allows the user to edit the properties of each triangle of a room's collision mesh. When the mode is activated, the collision mesh becomes visible, and the user
					can click on triangles to select them. Just like the actor editor, the properties of the selected triangles can be changed via the details panel on the right side of the screen. The
					right panel also contains the collision mesh's scenegraph. This is important because the elements of the scenegraph contain an important property: the terrain type of the geometry
					that is attached to them. <em>The Wind Waker</em> has three possible terrain types: solid, water, and lava. Water forces the player to enter a swimming state, while lava forces the
					player to void out. This property is not set per-triangle, as the other properties are; instead, it is applied to the scenegraph objects. Clicking once on a node in the scenegraph
					tree selects that node to edit its properties. However, to facilitate editing per-triangle properties on multiple triangles at once, double clicking a scenegraph node will
					instead select the <em>triangles</em> that are children of that node.
				</p><br>
				
				<h5 class="title has-text-grey-lighter">Text Editor</h5>
				<div class="card-image has-text-centered">
					<figure class="image is-256x256 is-inline-block"><img src="img/winditor_text.png" alt="a"/></figure>
				</div>
				<p>
					With Winditor's text editor, the user can modify the properties and contents of any message in the game. Addition of new messages is permitted, but removal is not; many objects in <em>The Wind Waker</em>
					reference messages based on index rather than their unique IDs, which means that removing messages will break those objects by changing where the messages are located in the file. When messages are added,
					the editor will check the existing messages to ensure that the new ones have their own unique IDs.
				</p>
				<p>
					The raw text data in <em>The Wind Waker</em> contains binary control codes, which tell the game engine to insert variables into the text or modify how it is drawn. To make it easy to
					work with these, they are converted into control tags contained within square brackets. For example, [red] will change the text color to red, while [white] reverts it to white. The [player] tag inserts the
					player's name into the text. Whenever the text changes, the editor validates any control tags that it finds. If invalid tags are found, an error is displayed as shown below:
				</p><br>
				<div class="card-image has-text-centered">
					<figure class="image is-256x256 is-inline-block"><img src="img/winditor_text_error.png" alt="a"/></figure>
				</div>
				
				<!-- SuperBMD -->
				<h3 class="title has-text-grey-lighter">SuperBMD</h3>
				<p><b>GitHub Repository:</b> <a href="https://github.com/Sage-of-Mirrors/SuperBMD">https://github.com/Sage-of-Mirrors/SuperBMD</a></p><br>
				<p>
					SuperBMD is a C# program that allows the user to work with BMD and BDL, the 3D model format that Nintendo used throughout the GameCube and Wii eras.
					It provides both importing and exporting functions, allowing the user to import skinned 3D meshes into GameCube and Wii games, and export skinned meshes
					to formats that are supported by common 3D modeling programs. Below are some examples of 3D models produced by SuperBMD.
				</p><br>
				
				<div class="container">
					<!-- Start Carousel -->
					<div id="carousel-poses" class="carousel">
						<div class="item-1">
							<div class="card-image has-text-centered">
								<figure class="image is-256x256 is-inline-block"><img src="img/sbmd_poe.png" alt="a"/></figure>
							</div>
						</div>
						<div class="item-2">
							<div class="card-image has-text-centered">
								<figure class="image is-256x256 is-inline-block"><img src="img/sbmd_octo.png" alt="a"/></figure>
							</div>
						</div>
						<div class="item-3">
							<div class="card-image has-text-centered">
								<figure class="image is-256x256 is-inline-block"><img src="img/sbmd_jal.png" alt="a"/></figure>
							</div>
						</div>
						<div class="item-4">
							<div class="card-image has-text-centered">
								<figure class="image is-256x256 is-inline-block"><img src="img/sbmd_stone.png" alt="a"/></figure>
							</div>
						</div>
					</div>
					<!-- End Carousel -->
				</div>
	
				<p>
					<em>3D models exported from the </em>The Legend of Zelda: The Wind Waker<em> and posed in Blender.</em>
				</p><br>
				
				<div class="container">
					<!-- Start Carousel -->
					<div id="carousel-models" class="carousel">
						<div class="item-1">
							<div class="card-image">
								<figure class="image is-256x256"><img src="img/sbmd_tetra_2.png" alt="a"/></figure>
							</div>
						</div>
						<div class="item-2">
							<div class="card-image">
								<figure class="image is-256x256"><img src="img/sbmd_medli_2.png" alt="a"/></figure>
							</div>
						</div>
						<div class="item-3">
							<div class="card-image">
								<figure class="image is-256x256"><img src="img/sbmd_trisuit.png" alt="a"/></figure>
							</div>
						</div>
						<div class="item-4">
							<div class="card-image">
								<figure class="image is-256x256"><img src="img/sbmd_cloud_2.png" alt="a"/></figure>
							</div>
						</div>
						<div class="item-5">
							<div class="card-image">
								<figure class="image is-256x256"><img src="img/sbmd_ashley_2.png" alt="a"/></figure>
							</div>
						</div>
					</div>
					<!-- End Carousel -->
				</div>
				<p>
					<em>Various 3D models imported over the player character in </em>The Wind Waker.<em> These models were rigged and/or created by
					members of the Wind Waker Randomizer community and imported into the game with SuperBMD.</em>
				</p><br>
				
				<div class="card-image has-text-centered">
					<figure class="video is-inline-block"><iframe src="https://www.youtube.com/embed/PQXB1v2NphQ?start=51" width="560" height="315" frameborder="0" allowfullscreen></iframe></figure>
				</div>
				<p>
					<em>An example of a player model replacement in </em>The Wind Waker<em> in motion. This video also demonstrates a text editor which I had
					previously developed; the text has been modified to say "big sister" instead of "big brother."</em>
				</p><br>
				
				<!-- Faura -->
				<h3 class="title has-text-grey-lighter">Faura</h3>
				<p><b>GitHub Repository:</b> <a href="https://github.com/Sage-of-Mirrors/Faura">https://github.com/Sage-of-Mirrors/Faura</a></p><br>
				<p>
					Faura is a C# tool for compiling and decompiling event scripts for games developed for the PlayStation 2 by Gust. It is specifically designed for the 2007
					<em>Ar Tonelico II: Melody of Metafalica</em>, but it is extensible such that it can be modified to work with Gust's other games. The tool's name comes from
					a constructed language used in the <em>Ar Tonelico</em> series called Hymmnos, where it means "small bird."
				</p><br>
				<p>
					The event binaries are made up of two pieces: text data and script commands. When Faura decompiles an event file, it produces a JSON file containing the text data and 
					an ASM-styled text file representing the script commands. A typical text entry looks like this:
				</p><br>
				<div class="box">
<pre>
{
  "Name": "msg_25",
  "IsUsed": "True",
  "TextboxType": "FULLPORTRAIT",
  "CharacterName": "SPICA",
  "CharacterID": "595",
  "PortraitPosition": "LEFT_CONVERSATION",
  "Text": "...even when everything was perfect."
},
</pre>
				</div>
				
				<p>
					While the ASM-style script data looks like this:
				</p><br>
								<div class="box">
<pre>
PlaySound 248 
SetScreenFade 255 10 
Wait 2 0 
Wait 0 1 
Wait 0 10 
SetScreenFade 0 40 
Wait 2 0 
DeductDP -16777216 
Wait 0 1 
Wait 0 120 
func_F138 
func_F0FE 6 

BeginBlock 6 
GoToBlock 8 
EndBlock 

BeginBlock 7 
GoToBlock 8 
EndBlock 

BeginBlock 8 
PlaySound 199 
PlaySound 361
</pre>
				</div>
				
				<p>
					Here, each line represents a single function call by the event. Each function lists its arguments. The functions are typically executed in a linear order; however,
					there are some control structures in place with the <code>BeginBlock</code> and <code>GoToBlock</code> functions. These allow the event to proceed differently
					based on various conditions, and they can even create loops that repeat actions until a condition is met or let the player confirm menu choices.
				</p><br>
				<p>
					Below is a video of a custom event that I wrote once Faura was advanced enough. It adapts part of a light novel based on <em>Ar Tonelico II</em>, and demonstrates
					much of what the event system of that game can do - character movement, emotion bubbles, conversation portraits, and so on.
				</p><br>
				
				<div class="card-image has-text-centered">
					<figure class="video is-inline-block"><iframe width="560" height="315" src="https://www.youtube.com/embed/g-5d6phiGc4" frameborder="0" allowfullscreen></iframe></figure>
				</div><br>
				
				<!-- Others -->
				<h3 class="title has-text-grey-lighter">Others</h3>
				<h5 class="title has-text-grey-lighter">Libgbacom and PC-TCG</h5>
				<p><b>GitHub Repositories:</b> <a href="https://github.com/Sage-of-Mirrors/libgbacom">https://github.com/Sage-of-Mirrors/libgbacom</a>, <a href="https://github.com/Sage-of-Mirrors/PC-TCG">https://github.com/Sage-of-Mirrors/PC-TCG</a></p><br>
				<p>
					Libgbacom is a C++ library that allows any program to communicate with the GameBoy Advance emulator VBA-M. Based on the GameCube emulator Dolphin's implementation,
					libgbacom uses SFML's networking functionality to speak with the emulator over the network. It is intended to be used by PC-TCG, which is a project that aims to restore
					GBA functionality to the PC port of Sonic Adventure 2: Battle. The game, originally released on the GameCube, had special GBA connectivity that was removed during the
					port. The project restores most of the original connectivity menus and will allow the game to communicate with VBA-M as if it were a GameCube.
				</p><br>
				
				<h5 class="title has-text-grey-lighter">3DS Physics Suite</h5>
				<p><b>GitHub Repository:</b> <a href="https://github.com/Sage-of-Mirrors/Physics_Suite">https://github.com/Sage-of-Mirrors/Physics_Suite</a></p><br>
				<p>
					This is a Nintendo 3DS homebrew application written in C++ that implements simple 2D physics calculations. It was written when I was taking a course called Physics in
					Game Engines, which went over the math involved with simluating physics. It was planned to have multiple modes, including a gravity simulation and a simple platformer,
					but those have yet to be implemented. Currently, the application will generate several circle objects of random sizes, colors, and velocities. When they collide with
					each other or the edges of the screen, they will bounce off.
				</p><br>
				
				<h5 class="title has-text-grey-lighter">GameCube Font Creator</h5>
				<p><b>GitHub Repository:</b> <a href="https://github.com/Sage-of-Mirrors/GamecubeFontCreator">https://github.com/Sage-of-Mirrors/GamecubeFontCreator</a></p><br>
				<p>
					GameCube Font Creator is a C# application for working with Nintendo's GameCube font format, BFN. It can dump the font images to PNG files, and it can encode font data
					to BFN files using the open source font format BMFont.
				</p><br>
				
				<div class="card-image has-text-centered">
					<figure class="image is-256x256 is-inline-block"><img src="img/font_papyrus.png" alt="a"/></figure>
					<figure class="image is-256x256 is-inline-block"><img src="img/font_sans.png" alt="a"/></figure>
				</div>
				<p><em>Examples of fonts imported into </em>The Wind Waker<em> using GameCube Font Creator. The fonts Papyrus and Comic Sans, respectively, replace the game's main text font.</em></p><br>
				
				<h5 class="title has-text-grey-lighter">Ocarina Text Editor</h5>
				<p><b>GitHub Repository:</b> <a href="https://github.com/Sage-of-Mirrors/Ocarina-Text-Editor">https://github.com/Sage-of-Mirrors/Ocarina-Text-Editor</a></p><br>
				<p>
					Ocarina Text Editor is a C# application for editing the text of <em>The Legend of Zelda: Ocarina of Time</em>. It is designed to work with the <em>Master Quest</em>
					debug ROM, but the hardcoded addresses used for loading and saving the text data can be easily modified to work with other versions of the ROM.<br>
					Notably, this editor
					fixes a long-standing issue that other editors had. The text data for <em>Ocarina of Time</em> includes a character map used for the title screen's "PRESS START" text,
					as well as the file select menu's banner. The location of this character map within the ROM is hardcoded into the game's boot routine, so other editors that modified
					where it was located would end up causing the text that relied on it to become garbled. Ocarina Text Editor fixes this error by forcing the character map message
					to be located at the start of the message data, and modifies the boot routine's address for it to reflect its new position.<br>
					<em>Ocarina of Time</em> handles text control codes in much the same way as <em>The Wind Waker</em>, and Ocarina Text Editor handles them in a similar manner.
					However, the control tags that Ocarina Text Editor serializes the control codes into reflect an earlier style that I preferred, using angled brackets instead of
					square brackets and simplifying the tags themselves to be as short as possible. For example, the tag &lt;C&gt; changes the text color to cyan, while &lt;W&gt; reverts it to white.
				</p><br>
				<div class="card-image has-text-centered">
					<figure class="image is-256x256 is-inline-block"><img src="img/ocarinatext.png" alt="a"/></figure>
				</div><br>
				
				<h5 class="title has-text-grey-lighter">Wind Waker Song Editor</h5>
				<p><b>GitHub Repository:</b> <a href="https://github.com/Sage-of-Mirrors/WindWakerSongEditor">https://github.com/Sage-of-Mirrors/WindWakerSongEditor</a></p><br>
				<p>
					One of my earliest projects, Wind Waker Song Editor is a C# application for editing the inputs required to trigger Wind Waker songs in the titular <em>Legend of Zelda</em> game.
					It provides the user with an interface, allowing them to select the song to edit, how many notes are in the song (3/4/6), and what each note in the song is. The notes are represented
					by the direction graphics that the game itself uses.
				</p><br>
				<div class="card-image has-text-centered">
					<figure class="image is-256x256 is-inline-block"><img src="img/songeditor.png" alt="a"/></figure>
				</div>
			</div>
		</div>
	 </div>
	</section>
	
	<script src="js/bulma-carousel.min.js"></script>
	<script>
	bulmaCarousel.attach('.carousel', {
		slidesToScroll: 1,
		slidesToShow: 1
	});
	</script>
  </body>
</html>